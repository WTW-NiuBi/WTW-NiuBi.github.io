<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>JavaScript基础学习笔记 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="js是什么？javascript是一门面向对象的语言。 JavaScript是严格区分大小写的，也就是abc和Abc会被解析器认为是两个不同的东西。 js输出​    document.write   向body中写字符串​    console.log      向控制台输出​    alert            弹出警告框输出 js编写位置​    1.外联文件 1&lt;script s">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript基础学习笔记">
<meta property="og:url" content="http://example.com/2023/10/22/JavaScript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="js是什么？javascript是一门面向对象的语言。 JavaScript是严格区分大小写的，也就是abc和Abc会被解析器认为是两个不同的东西。 js输出​    document.write   向body中写字符串​    console.log      向控制台输出​    alert            弹出警告框输出 js编写位置​    1.外联文件 1&lt;script s">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-10-22T08:53:54.000Z">
<meta property="article:modified_time" content="2023-11-05T15:58:57.019Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="前端学习">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-JavaScript基础学习笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/22/JavaScript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2023-10-22T08:53:54.000Z" itemprop="datePublished">2023-10-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JS/">JS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      JavaScript基础学习笔记
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="js是什么？"><a href="#js是什么？" class="headerlink" title="js是什么？"></a>js是什么？</h2><p>javascript是一门面向对象的语言。</p>
<p>JavaScript是严格区分大小写的，也就是abc和Abc会被解析器认为是两个不同的东西。</p>
<h2 id="js输出"><a href="#js输出" class="headerlink" title="js输出"></a>js输出</h2><p>​    <code>document.write</code>   向body中写字符串<br>​    <code>console.log</code>      向控制台输出<br>​    <code>alert</code>            弹出警告框输出</p>
<h2 id="js编写位置"><a href="#js编写位置" class="headerlink" title="js编写位置"></a>js编写位置</h2><p>​    1.外联文件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;引入的文件位置&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    2.内联文件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line">          js代码编写的位置</span><br><span class="line"> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    3.内嵌代码(结构与行为耦合，不使用)</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;弹出&#x27;)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:alert(&#x27;弹出&#x27;);&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="js基本语法"><a href="#js基本语法" class="headerlink" title="js基本语法"></a>js基本语法</h2><pre><code>   1. 严格**区分大小写**
   2. 语句分号结尾
   3. 没有添加分号时浏览器自动添加，但是消耗资源并且可能添加出错
</code></pre>
<h2 id="js字面量和变量"><a href="#js字面量和变量" class="headerlink" title="js字面量和变量"></a>js字面量和变量</h2><pre><code>1. 字面量即为常量
   2. 变量可被字面量赋值
   3. 变量声明和赋值可分开或一起       
</code></pre>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>​    或者</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="js标识符"><a href="#js标识符" class="headerlink" title="js标识符"></a>js标识符</h2><p>​    所有可以自定义的变量都叫做标识符，并且遵循以下规范：<br>​        1.只能以字母数字，下划线，$构成<br>​        2.不能以数字开头<br>​        3.不能使用ES的关键字和保留字<br>​        4.一般使用<strong>驼峰命名法</strong><br>​    标识符以<code>unicode</code>编码表示，因此可以使用<code>UTF-8</code>的所有内容，但是一般只使用英文</p>
<h2 id="js基本数据类型"><a href="#js基本数据类型" class="headerlink" title="js基本数据类型"></a>js基本数据类型</h2><h3 id="1-string"><a href="#1-string" class="headerlink" title="1.string"></a>1.string</h3><h3 id="2-number"><a href="#2-number" class="headerlink" title="2.number"></a>2.number</h3><p>可以表示整数与浮点数<br>2进制浮点数以分数表示，不准确<br>NaN与Infinity是数值的字面量，表示非数与无穷<br>typeof 参数  检测某个值的类型</p>
<h3 id="3-boolean"><a href="#3-boolean" class="headerlink" title="3.boolean"></a>3.boolean</h3><p>​        只有两个值：true  false</p>
<h3 id="4-null"><a href="#4-null" class="headerlink" title="4.null"></a>4.null</h3><p>表示一个空对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a);</span><br></pre></td></tr></table></figure>

<p> 结果为<code>object</code></p>
<h3 id="5-undefined"><a href="#5-undefined" class="headerlink" title="5.undefined"></a>5.undefined</h3><p> <strong>已经声明的变量未赋值</strong>则成为undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a);</span><br></pre></td></tr></table></figure>

<p> 结果为undefined</p>
<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><h3 id="1-string-1"><a href="#1-string-1" class="headerlink" title="1.string"></a>1.string</h3><p>两种办法：</p>
<blockquote>
<p>a.toString()  </p>
<p>String()</p>
</blockquote>
<p><code>toString</code>只能用于对象，因此null和undefined无法调用</p>
<p><code>String()</code>对于Number, String, Boolean来说会调用底层的toString()方法，对于null和undefined会直接进行转换</p>
<h3 id="2-number-1"><a href="#2-number-1" class="headerlink" title="2.number"></a>2.number</h3><p>三种方法：</p>
<blockquote>
<p>Number(), <strong>parseInt()</strong>, parseFloat()</p>
</blockquote>
<p>Number()：</p>
<ul>
<li>对于字符串来说如果只包含数字，直接转换成数字，如果包含非数字转换成NaN，如果是””或者”  “则转换成0</li>
<li>对于boolean值，true转换成1，false转换成0</li>
<li>对于null，转换成0</li>
<li>对于undefined，转换成NaN</li>
</ul>
<p>parseInt()：</p>
<ul>
<li>首先将所有内容转换成字符串再开始解析。</li>
<li>从左到右依次解析，需要非整数直接舍去，第一位非整数返回NaN</li>
</ul>
<p>parseFloat()：</p>
<ul>
<li>与parseInt()相似，只是遇到<strong>第一位小数点</strong>不会忽略会转换成小数，其余与之相同</li>
</ul>
<h3 id="3-boolean-1"><a href="#3-boolean-1" class="headerlink" title="3.boolean"></a>3.boolean</h3><p>一种方法：</p>
<blockquote>
<p>Boolean()</p>
</blockquote>
<ul>
<li>对于数字：只有0跟NaN会转换成false</li>
<li>对于字符串：只有””会转换成false</li>
<li>对于null和undefined，只会转换成false</li>
</ul>
<h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><ul>
<li><p>16进制在数字前加0x</p>
</li>
<li><p>8进制在数字前加0</p>
<p>在某些浏览器中键入以下代码：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;070&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(a));</span><br></pre></td></tr></table></figure>

<p>​		结果会输出56。因为浏览器将其当做8进制，解决方法是输入第二个参数，强制以10进制输出<br>​		<strong>parseInt(a, 10);</strong></p>
<ul>
<li><p>2进制在数字前加0b</p>
<p>某些浏览器无法解析2进制如IE浏览器，同时也不常用</p>
</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>运算符有以下种类：<code>typeof</code>，<code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code></p>
<p>所有的运算符都不改变原始变量而是返回进行运算后的结果,并且<strong>NaN与任何值进行运算结果都为NaN</strong></p>
<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof:"></a>typeof:</h3><p>typeof返回一个变量或者字面量的类型，返回值为string</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">typeof</span> <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a);</span><br></pre></td></tr></table></figure>

<p>结果为：number与string</p>
<h3 id="："><a href="#：" class="headerlink" title="+："></a>+：</h3><p>数字的加法运算</p>
<ul>
<li>遇到非number的值，会将其<strong>转换成number</strong></li>
<li>遇到string的值，会<strong>转换成string</strong>然后进行<strong>接串</strong>操作，可应用于长字符串的换行与<strong>隐性string类型转换</strong></li>
<li>其余运算符进行相应数学运算并且在遇到非number值时，会全部<strong>转换成number值</strong>后再进行运算操作，此特性可用于<strong>隐式number类型转换</strong>，但还有更简单的方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a / <span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> (a / <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>​        结果为123和number类型</p>
<h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><h4 id="正号-和负号"><a href="#正号-和负号" class="headerlink" title="正号+和负号-"></a>正号+和负号-</h4><p>两者能够进行相应的数学运算同时在遇到非number的值时会将其<strong>强制转换成number值</strong>再进行运算，此特性可用于<strong>隐式number类型转换</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> +a);</span><br></pre></td></tr></table></figure>

<p>结果为123和number类型</p>
<h3 id="自增与自减"><a href="#自增与自减" class="headerlink" title="自增与自减"></a>自增与自减</h3><h4 id=""><a href="#" class="headerlink" title="++"></a>++</h4><p>分为前++(++a)和后++(a++)，对于a值来说都是增加1，但是表达式的返回值不同，前++返回新值，后++返回原值</p>
<h3 id="-1"><a href="#-1" class="headerlink" title="- -"></a>- -</h3><p>特性与自增相同，只是对于a值来说是减少1</p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>包括<code>!</code>, <code>&amp;&amp;</code>, <code>||</code>三种运算符</p>
<ul>
<li>!：两次取非会得到原值的布尔值，可以利用这个特性进行<strong>隐式布尔值转换</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + !!a);</span><br></pre></td></tr></table></figure>

<p>​         结果为true，与Boolean(a)相同</p>
<ul>
<li><p>&amp;&amp;：两个值都为true结果才为true</p>
</li>
<li><p>||：两个值都为false结果才为false</p>
</li>
</ul>
<p>在JS中<code>&amp;&amp;</code>与<code>||</code>都是属于短路操作，即<strong>当一个值满足要求时才会继续执行第二个操作</strong>，第一个值不满足要求时不执行第二个操作</p>
<p>当参数不是boolean值时<strong>先会将参数转换成boolean值</strong>后再按照以上规则输出原值</p>
<p><strong>&amp;&amp;：</strong></p>
<p>当第一个值为true时，返回第二个值</p>
<p>当第一个值为false时，返回第一个值</p>
<blockquote>
<p>console.log(“123” &amp;&amp; “456”);</p>
<p>结果为”456”</p>
<p>console.log(NaN &amp;&amp; “111”);</p>
<p>结果为NaN</p>
</blockquote>
<p><strong>||：</strong></p>
<p>当第一个值为false时，返回第二个值</p>
<p>当第一个值为true时，返回第一个值</p>
<blockquote>
<p>console.log(NaN || “111”);</p>
<p>结果为”111”</p>
<p>console.log(“123” || “456”);</p>
<p>结果为”123”</p>
</blockquote>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>有以下几种：<code>=</code>,<code> +=</code>,<code> -=</code>,<code> /=</code>,<code> *=</code></p>
<blockquote>
<p>var a +&#x3D; 3;</p>
<p>var a &#x3D; a + 3;</p>
</blockquote>
<p>两者等价，对于其他的赋值运算符，与<code>+=</code>规则相同</p>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>有以下几种：<code>&lt;</code>,<code> &gt;</code>,<code> &lt;=</code>,<code> &gt;=</code></p>
<ul>
<li>有一方为number值时，将非number值转换成number值再进行比较</li>
<li>NaN与任何值进行任何比较结果都为false， 包括NaN本身</li>
</ul>
<blockquote>
<p>console.log(NaN &gt;&#x3D; NaN);</p>
</blockquote>
<p>​		结果为false</p>
<ul>
<li>当两方都为string时，按位比较字符编码，因此在两者都为string类型值为数字时进行比较，结果可能不符合预期，可应用于英文名字的排序</li>
</ul>
<blockquote>
<p>console.log(“11” &gt; “2”);</p>
</blockquote>
<p>​		结果为false</p>
<h3 id="unicode编码"><a href="#unicode编码" class="headerlink" title="unicode编码"></a>unicode编码</h3><p>在js中使用时在编码前加\u对编码进行转义输出</p>
<blockquote>
<p>console.log(“\u0031”);</p>
</blockquote>
<p>结果为1，编码为16进制</p>
<p>在HTML中使用时以 &amp;#编码; 的格式输出</p>
<blockquote>
<p>&amp; #0048;</p>
</blockquote>
<p>结果为1，编码为10进制</p>
<h3 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h3><p>包括<code>==</code>, <code>!=</code>, <code>===</code>, <code>!==</code>,</p>
<ul>
<li>&#x3D;&#x3D;, !&#x3D;</li>
</ul>
<p>​	两者类型相同时判断是否相等，类型不同时进行类型转换再判断是否相等，转换成哪种类型无法确定</p>
<p>​	<strong>由于undefined衍生于null，因此两者相等</strong></p>
<blockquote>
<p>console.log(undefined &#x3D;&#x3D; null);</p>
</blockquote>
<p>​	结果为true</p>
<p>​	<strong>NaN与任何值进行运算结果都为false，包括自己</strong></p>
<blockquote>
<p>console.log(NaN &#x3D;&#x3D; NaN);</p>
</blockquote>
<p>​	结果为false</p>
<ul>
<li>&#x3D;&#x3D;&#x3D;, !&#x3D;&#x3D;</li>
</ul>
<p>​	除不进行类型转换外，规则与&#x3D;&#x3D;, !&#x3D;&#x3D;类似</p>
<p>​	当两者<strong>类型不同</strong>时，&#x3D;&#x3D;&#x3D;直接返回false，!&#x3D;&#x3D;直接返回true</p>
<p>​	NaN的规则在此处同样适用</p>
<blockquote>
<p>console.log(NaN &#x3D;&#x3D;&#x3D; NaN);</p>
</blockquote>
<p>​	结果为false</p>
<p>​	undefined与null在这种运算符下，才会不相等</p>
<blockquote>
<p>console.log(undefined &#x3D;&#x3D;&#x3D; null);</p>
</blockquote>
<p>​	结果为false</p>
<h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>语法格式为**(表达式)?(语句1):(语句2**);</p>
<p>当表达式结果为true时执行语句1，否则执行语句2</p>
<p>当表达式结果为非boolean值时，会转换成boolean值后再对表达式进行判断</p>
<h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><p>用来分割不同语句，可以同时声明多个变量</p>
<h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>按照优先级表进行先后运算，可以<strong>使用()改变优先级</strong></p>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p> 将多个语句用{}包含起来，这一堆语句称为代码块，它只具有分组的作用，没有其他用途</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>结果为1 &#x2F;n 1</p>
<h2 id="条件判断语句"><a href="#条件判断语句" class="headerlink" title="条件判断语句"></a>条件判断语句</h2><p>语法1：满足条件只执行紧接着的第一条语句，后面语句与判断语句无关</p>
<blockquote>
<p>​		if(表达式)</p>
<p>​			语句1;</p>
</blockquote>
<p>语法2：满足条件执行代码块中的代码，代码块外的代码与判断语句无关</p>
<blockquote>
<p>​        if(表达式){</p>
<p>​            语句1;</p>
<p>​            语句2;</p>
<p>​        } </p>
</blockquote>
<p>语法3：满足条件执行前一个代码块中的代码，否则执行后一个代码块中的代码</p>
<blockquote>
<p>​        if(表达式){</p>
<p>​            语句…</p>
<p>​        }else{</p>
<p>​            语句…</p>
<p>​        }</p>
</blockquote>
<p>语法4：从上到下依次判断，当满足一个表达式后后面的代码不再执行</p>
<blockquote>
<p>​        if(表达式){</p>
<p>​            语句…</p>
<p>​        }else if{</p>
<p>​            语句…</p>
<p>​        }else if{</p>
<p>​            语句…</p>
<p>​        }else if{</p>
<p>​            语句…</p>
<p>​        }else{</p>
<p>​            语句…</p>
<p>​        }</p>
</blockquote>
<p>语法5：条件判断语句可以嵌套</p>
<blockquote>
<p>​        if(表达式){</p>
<p>​            语句…</p>
<p>​        }else{</p>
<p>​            语句…</p>
<p>​            if(表达式){</p>
<p>​                语句…</p>
<p>​            }</p>
<p>​        }</p>
</blockquote>
<h2 id="条件分支语句"><a href="#条件分支语句" class="headerlink" title="条件分支语句"></a>条件分支语句</h2><p>语法：</p>
<blockquote>
<p>​        switch(表达式){<br>​            case 值1:<br>​                语句…<br>​                break;<br>​            case 值2:<br>​                语句…<br>​                break;<br>​            case 值3:<br>​                语句…<br>​                break;<br>​            default:<br>​                语句…<br>​                break;<br>​        }</p>
</blockquote>
<p>break;语句用来跳出switch语句，当没有此语句时，如果表达式的值满足某个case时，后面的语句都会执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span>(a)&#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">     <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">     <span class="attr">default</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;其他&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 结果为1, 2, 其他</p>
<h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><h3 id="while语句："><a href="#while语句：" class="headerlink" title="while语句："></a>while语句：</h3><p>语法1：</p>
<blockquote>
<p>​            while(true){    &#x2F;&#x2F;1.将表达式写死<br>​                if(条件表达式){  &#x2F;&#x2F;2.当满足某种条件时退出<br>​                    break;<br>​                }<br>​                语句…<br>​            }</p>
</blockquote>
<p>语法2：</p>
<blockquote>
<p>​            var i &#x3D; 0;     &#x2F;&#x2F;1.初始化变量<br>​            while(i &lt; 10){  &#x2F;&#x2F;2.当不满足条件时退出循环<br>​                语句…<br>​                i++;        &#x2F;&#x2F;3.更新变量<br>​            }</p>
</blockquote>
<h3 id="do-while-语句："><a href="#do-while-语句：" class="headerlink" title="do{}while()语句："></a>do{}while()语句：</h3><p>语法：</p>
<blockquote>
<p>​            do{<br>​                语句…<br>​            }while(表达式)</p>
</blockquote>
<p> 与while语句的唯一不同是，while语句<strong>先对表达式进行判断</strong>，当不满足条件时不继续执行后面的代码块，而do{}while()语句是<strong>先执行do后面的代码块再判断表达式</strong>，不满足时不执行第二次</p>
<blockquote>
<p>​            var i &#x3D; 11;<br>​            while(i &lt;&#x3D; 10){<br>​                console.log(i);<br>​            }</p>
</blockquote>
<p>结果为无</p>
<blockquote>
<p>​            do{<br>​                console.log(i);<br>​            }while(i &lt;&#x3D; 10)</p>
</blockquote>
<p>结果为11</p>
<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>语法：</p>
<blockquote>
<p>​        for(初始化变量; 条件表达式; 更新变量){</p>
<p>​    }</p>
</blockquote>
<p>作用与while循环相同，写法也可与while循环语法2相同，只要初始化变量与更新变量分别写在for循环外部与内部</p>
<blockquote>
<p>​    var a &#x3D; 0;<br>​    for(; a&lt; 10;){<br>​        a++;<br>​    }</p>
</blockquote>
<p>当for循环表达式不写任何内容时则成为死循环</p>
<blockquote>
<p>​    for(;;){</p>
<p>​    }</p>
</blockquote>
<h2 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h2><p><strong>break; 用来跳出循环或者switch</strong></p>
<p>用在循环语句时跳出最近的循环，不能跳出if语句</p>
<p><strong>continue; 用来跳过当前循环，执行下一次循环</strong></p>
<p>不能跳出if语句</p>
<p><strong>label：在循环语句的前一行使用label语句用来标识某一个循环</strong></p>
<p>两者都可增加参数，参数是循环的标识名，可以跳出所指定的循环</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">good</span>:</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">1</span>; j&lt;<span class="number">10</span>; j++)&#123;</span><br><span class="line">             <span class="keyword">break</span> good;       </span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>结果只有一个1</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">bad</span>:</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">1</span>; j&lt;<span class="number">10</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span> bad;       </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p> 结果为1,3,4,5,6,7,8,9</p>
<h2 id="优化程序效率"><a href="#优化程序效率" class="headerlink" title="优化程序效率"></a>优化程序效率</h2><ul>
<li>可以考虑在循环语句中增加break;来提高程序运行效率</li>
<li>使用console.time(“字符串标志”);来标记一个计时器</li>
<li>使用console.timeEnd(“字符串标志”);来结束某个计时器并打印出计时器经过的时间</li>
</ul>
<blockquote>
<p>console.time(“a”);<br>console.timeEnd(“a”);</p>
</blockquote>
<p>​		结果是名为a的计时器经过的时间，单位是ms，只能用在浏览器中</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象属于复合数据类型，有三种，分别是：</p>
<p><strong>1.内建对象</strong><br>由ES标准中内建的对象，在任何的ES实现中都可以使用，如Math, String, Boolean, Number, Function, Object…</p>
<p><strong>2.宿主对象</strong><br>由js运行的环境所提供的对象，一般指浏览器，如DOM, BOM…</p>
<p><strong>3.自定义对象</strong><br>由开发人员自定义的对象</p>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>var obj &#x3D; new Object();</p>
<p>**new所调用的函数是一个构造函数constructor()**，构造函数是专门用来创建对象的函数</p>
<p>使用typeof语句会返回object</p>
<h3 id="增加属性"><a href="#增加属性" class="headerlink" title="增加属性"></a>增加属性</h3><p>语法：<br>​        对象.属性名 &#x3D; 属性值;<br>​         obj.name &#x3D; “111”;</p>
<p>属性名可以不遵循标识符的规范，不遵循规范时需要其他方式来增删查改，但是一般尽量遵守规范，属性值可以是任何数据类型，包括null,undefined,object，当是object时可以无限嵌套</p>
<blockquote>
<p>​            var obj2 &#x3D; new Object();<br>​            obj2.name &#x3D; “333”;<br>​            obj.test &#x3D; obj2;</p>
</blockquote>
<h3 id="修改属性"><a href="#修改属性" class="headerlink" title="修改属性"></a>修改属性</h3><p>​        语法：<br>​            对象.属性名 &#x3D; 属性值;<br>​            obj.name &#x3D; “222”;<br>​        与增加属性方法类似，只是将已有值覆盖</p>
<h3 id="查询属性"><a href="#查询属性" class="headerlink" title="查询属性"></a>查询属性</h3><p>​        语法：<br>​            对象.属性名<br>​            console.log(obj.name);<br>​            结果为222<br>​        当对象的属性为另一个对象时.重复使用来获取对象的对象的属性值<br>​            console.log(obj.test.name);<br>​            结果为”333”</p>
<h3 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h3><p>​        语法：<br>​            delete 对象.属性<br>​            delete obj.name;<br>​            console.log(obj.name);<br>​            结果为undefined<br>​    当查询对象的某个属性不存在时，会返回undefined<br>​    当属性名没有遵循标识符规范时需要使用[]来增删查改相应属性，属性名可以是变量或者字符串<br>​        语法：<br>​            对象[属性名] &#x3D; 属性值;<br>​            obj[“123”] &#x3D; 345;  &#x2F;&#x2F;字符串<br>​            var test &#x3D; “123”;<br>​            console.log(obj[test]);  &#x2F;&#x2F;变量<br>​            结果为345</p>
<h3 id="in语句"><a href="#in语句" class="headerlink" title="in语句"></a>in语句</h3><p>​        用来查询某个对象是否有相应属性名,属性名必须是字符串或者是变量，有则返回true，没有返回false<br>​        语法：<br>​            属性名 in 对象;<br>​            console.log(“123” in obj);<br>​            结果为true</p>
<h2 id="基本和引用数据类型"><a href="#基本和引用数据类型" class="headerlink" title="基本和引用数据类型"></a>基本和引用数据类型</h2><ul>
<li><p>在js中，内存分为栈内存和堆内存，因为基本数据大小一般比较小，js专门将这些数据存放在固定的内存范围内即栈内存来保存变量与变量值，而引用数据大小一般较大，js需要创建新内存空间即堆内存来保存对象的内容</p>
</li>
<li><p>当声明变量时，会在栈内存最下层中新建一个变量</p>
</li>
<li><p>取值时按照声明顺序取值</p>
</li>
<li><p>当调用new新建对象时会在堆内存中创建新的内存空间来新建一个对象</p>
</li>
<li><p>由于新建的内存地址不确定，取对象时需要用相应内存地址取用相应的对象</p>
</li>
<li><p>给变量赋值为基本数据类型时，会直接修改栈内存中变量对应的变量值为相应的变量值</p>
</li>
<li><p>给变量赋值为引用数据类型时，会直接修改栈内存中变量对应的变量值为内存地址</p>
</li>
<li><p>两个变量的内存地址指向同一个对象时，修改一个变量的对象的值，另一个变量的对象的值也会发生改变</p>
<blockquote>
<p>​		var obj1 &#x3D; new Object();<br>​        obj.name &#x3D; “111”;<br>​        var a &#x3D; obj1,b &#x3D; obj1;<br>​        a.name &#x3D; “222”;<br>​        console.log(b.name);</p>
</blockquote>
<p>结果为222</p>
</li>
</ul>
<h2 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h2><p>可以使用对象字面量来新建对象，效果与new Object()相同</p>
<p>语法：</p>
<blockquote>
<p>​        {属性名: 属性值, 属性名: 属性值…};<br>​        var obj &#x3D; {name: “a”, age: “16”, gender: “男”};</p>
</blockquote>
<p>属性名可以使用引号包起来，但是一般不使用，当属性名不遵循标识符规范时，需要使用引号包起来，最后一个属性写完后不加逗号</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>函数也是对象</strong>，它具有普通对象具有的所有功能</p>
<h3 id="声明函数："><a href="#声明函数：" class="headerlink" title="声明函数："></a>声明函数：</h3><ul>
<li>新建函数对象：</li>
</ul>
<p>​            语法：<br>​                var func &#x3D; new Function(“需要执行的代码块”);<br>​                在构造函数中可以加入字符串参数代码使得调用函数时可以直接执行<br>​                var func &#x3D; new Function(“console.log(111)”);<br>​                func();<br>​                结果为111</p>
<ul>
<li>函数声明：</li>
</ul>
<p>​            语法：<br>​                function func([形参1,形参2, 形参3…]){<br>​                    语句…<br>​                }</p>
<ul>
<li>函数表达式:</li>
</ul>
<p>​            语法：<br>​                var func &#x3D; function([形参1,形参2, 形参3…]){<br>​                    语句…<br>​                }</p>
<h2 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h2><ul>
<li>声明函数时传递的参数叫形参，作用相当于在函数内部声明变量</li>
<li>调用函数时传递的参数叫实参，作用相当于给函数的形参赋值</li>
<li>当实参数量大于形参时，多出来的实参会被忽略</li>
<li>当实参数量小于形参时，未赋值的形参会是undefined类型</li>
<li>实参可以是任意数据类型包括对象与函数，当实参数量过多时，可以考虑将部分实参封装成一个对象传入</li>
<li>将函数当做实参传入另一个函数：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">func2</span>(<span class="params">a</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">func2</span>(func1);       <span class="comment">//结果为func1对象本身，结果为func1函数的内容</span></span><br><span class="line">​       <span class="title function_">func2</span>(<span class="title function_">func1</span>());     <span class="comment">//结果为func1的函数返回值,结果为1</span></span><br></pre></td></tr></table></figure>



<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><ul>
<li>使用return语句可以让函数返回特定的值，此时函数中return后面跟的所有语句都不执行</li>
</ul>
<p>​    语法：<br>​        return [返回值];</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="title function_">test</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure>

<p>结果为3</p>
<ul>
<li>当return后不加参数时，相当于函数返回undefined</li>
<li>函数中不使用return时，也相当于返回undefined</li>
<li>返回值可以是任意类型，包括对象和函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">func2</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;func2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> func2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="title function_">func1</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br></pre></td></tr></table></figure>

<p>结果为func2函数本身的内容</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">a</span>());       <span class="comment">//与console.log(func1()());相同</span></span><br></pre></td></tr></table></figure>

<p>结果为”func2”</p>
<h2 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h2><p>语法：</p>
<blockquote>
<p>​        (function([形参1, 形参2…]){<br>​            语句…<br>​        })([实参1, 实参2…])</p>
</blockquote>
<p>​    当写成以下形式时，js会将前半部分当成代码块，无法识别函数声明</p>
<blockquote>
<p>​        function([形参1, 形参2…]){<br>​            语句…<br>​        }([实参1, 实参2…])</p>
</blockquote>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>由于对象的属性可以是任何值，因此也可以将一个函数赋值给一个对象的属性，此时这个函数属性就被叫做方法，需要注意的是，函数与方法只是名称上的不同，其他没有任何区别</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&quot;111&quot;</span>;</span><br><span class="line">obj.<span class="property">callName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">callName</span>();</span><br></pre></td></tr></table></figure>

<p> 结果为”111”</p>
<p><strong>调用对象中的函数，被称为调用这个对象的方法</strong></p>
<h2 id="枚举语句"><a href="#枚举语句" class="headerlink" title="枚举语句"></a>枚举语句</h2><p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> 声明变量 <span class="keyword">in</span> 对象)&#123;</span><br><span class="line">    语句...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);     <span class="comment">//i为obj对象的属性名</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj[i]);        <span class="comment">//obj[i]为obj对象的属性值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象中有多少个属性，这个循环便会执行多少次</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>直接写在script标签中的代码都属于全局作用域，它在打开页面时创建，在关闭页面时销毁</p>
<ul>
<li>全局作用域中所有的变量可以在页面的任意部分被访问到</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​            结果为1</p>
<ul>
<li>全局作用域中所有声明的变量都会被创建成window对象的属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">a</span>);</span><br></pre></td></tr></table></figure>

<p>​            结果为1</p>
<ul>
<li>变量的提前声明</li>
</ul>
<p>​	当使用var来声明或者声明并赋值变量时，无论声明位置在何处，声明本身这个语句会在当前script标签中的最	顶端被执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>​	结果为undefined而不是报错，因为var a;这条语句已经在代码最顶端被执行过了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>​	报错，a未被声明</p>
<ul>
<li>函数的提前声明</li>
</ul>
<p> 无论函数在何处被声明，函数声明本身会在任何代码前被执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">func1</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为”1”</p>
<p>但是对于函数表达式来说，由于使用var来声明函数，因此只符合变量提前声明的特性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">func1</span>();</span><br><span class="line"><span class="keyword">var</span> func1 = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果报错，undefined不是一个函数</p>
<h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>函数作用域在函数执行时创建，在执行完毕后销毁，在函数作用域内部与全局作用域相似</p>
<p>当在函数中使用变量时会先向当前作用域查找，没有则向上一级作用域查找，直到全局作用域，如果全局作用域中没有此变量时报错</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">func2</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">func2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func1</span>();</span><br></pre></td></tr></table></figure>

<p>结果为1</p>
<p>在函数作用域中可以访问到全局作用域的变量，反之不成立</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br></pre></td></tr></table></figure>

<p>结果为报错，a未定义</p>
<p>在函数作用域中变量声明提前与函数声明提前同样适用（当函数有形参时相当于在函数内部声明了变量）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func1</span>();</span><br></pre></td></tr></table></figure>

<p>  结果为undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"></span>)&#123;</span><br><span class="line">               <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">               <span class="title function_">func2</span>();</span><br><span class="line">               <span class="keyword">function</span> <span class="title function_">func2</span>(<span class="params"></span>)&#123;</span><br><span class="line">                   <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

<p>结果为1</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>当调用函数时，解析器会<strong>隐式传入</strong>一个参数this，它是一个<strong>对象</strong></p>
<p>​    1.当以函数的形式调用时，this永远是全局作用域window</p>
<p>​    2.当以对象的方法调用时，this是调用这个方法的对象</p>
<p>​    3.当以构造函数调用时，this就是新创建的对象</p>
<p>作用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="number">1</span>, obj1 = &#123;<span class="attr">name</span>: <span class="number">2</span>, <span class="attr">sayName</span>: func&#125;, obj2 = &#123;<span class="attr">name</span>:<span class="number">3</span>, <span class="attr">sayName</span>: func&#125;;</span><br><span class="line"><span class="title function_">func</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func</span>();</span><br><span class="line">obj1.<span class="title function_">sayName</span>();</span><br><span class="line">obj2.<span class="title function_">sayName</span>();</span><br></pre></td></tr></table></figure>

<p>结果为1, 2, 3</p>
<p>可以使用this来使方法&#x2F;函数内的值发生变化</p>
<h2 id="创建对象-1"><a href="#创建对象-1" class="headerlink" title="创建对象"></a>创建对象</h2><p>有几种方法被用来方便地创建对象</p>
<p><strong>instanceof</strong>语句来输出对象的类名</p>
<p>工厂方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    obj.<span class="property">name</span> = name;</span><br><span class="line">    obj.<span class="property">age</span> = age;</span><br><span class="line">    retrun obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createDog</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    obj.<span class="property">name</span> = name;</span><br><span class="line">    obj.<span class="property">age</span> = age;</span><br><span class="line">    retrun obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="title function_">createPerson</span>(<span class="string">&quot;aaa&quot;</span>, <span class="number">16</span>);</span><br><span class="line"><span class="keyword">var</span> dog = <span class="title function_">createDog</span>(<span class="string">&quot;bbb&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">instanceof</span> person);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">instanceof</span> dog);</span><br></pre></td></tr></table></figure>

<p>结果都为Object</p>
<p>缺点：无法得知所创建的是一个什么对象，所以出现了<strong>构造函数</strong>来解决这个问题</p>
<h3 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;aaa&quot;</span>, <span class="number">16</span>);</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;ccc&quot;</span>, <span class="number">14</span>);</span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;bbb&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">instanceof</span> person1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">instanceof</span> dog);</span><br></pre></td></tr></table></figure>

<p>结果分别为Person， Dog</p>
<p>构造函数与普通函数在使用上的区别就是<strong>是否使用了new</strong>，构造函数又被称为<strong>类</strong>，对类作new操作等到的结果被称为实例</p>
<p><strong>构造函数的执行流程：</strong></p>
<ol>
<li>立即新建1个对象</li>
<li>将构造函数的this值赋值为新创建的对象</li>
<li>依次执行构造函数内的代码</li>
<li>将新建的对象返回</li>
</ol>
<p>构造函数改进:</p>
<p>按照上述代码编写会在给对象创建方法时重复创建函数，当实例化类次数增加时会浪费大量内存，因此需要将重复创建的方法函数变成只创建一次</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">sayName</span> == person2.<span class="property">sayName</span>);</span><br></pre></td></tr></table></figure>

<p>结果为false，证明的确重复创建了函数</p>
<p>可以将方法声明在全局作用域中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = func;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;aaa&quot;</span>, <span class="number">16</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;bbb&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">sayName</span> == person2.<span class="property">sayName</span>);</span><br></pre></td></tr></table></figure>

<p>结果为true,证明是同一个函数</p>
<p>但是这种办法会污染全局命名空间并且不够安全，有可能会被其他函数覆盖</p>
<h3 id="原型对象："><a href="#原型对象：" class="headerlink" title="原型对象："></a>原型对象：</h3><p><strong>每一个类都可以有一个原型对象prototype</strong>，它是一个<strong>对象</strong>，并且这个类的实例会有一个原型属性、__proto__，它的值是这个实例的类的原型对象地址</p>
<p>因此修改类的原型对象的属性也会改变这个类的实例的原型属性所指向的那个原型对象</p>
<p>可以利用原型的特性为类开辟出一个新的公共空间让这个类的每一个实例都可以使用这个公共空间的值或者方法而<strong>不会污染全局命名空间</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;a&quot;</span>,<span class="number">12</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.\_\_proto\_\_ == <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br></pre></td></tr></table></figure>

<p>结果为true</p>
<p><strong>所有对象都有原型属性__proto__<strong>，由于原型对象也是对象，因此</strong>也具有原型属性__proto__</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.\_\_proto\_\_);</span><br></pre></td></tr></table></figure>

<p>结果为object</p>
<p><strong>Object的实例的原型没有原型</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.\__proto\_\_.\_\_proto\_\_);</span><br></pre></td></tr></table></figure>

<p>结果为null</p>
<p><strong>所有对象都是Object对象的实例</strong>，包括<strong>原型对象</strong>，因此原型的回溯最多到<strong>Object实例的原型</strong>为止，也就是原型对象的原型为止</p>
<p>实例中变量查找顺序：</p>
<ol>
<li>先在被实例化的类中的变量之间查找，如果找到则输出，否则进入它的原型对象</li>
<li>在类中的原型对象中的变量之间查找，如果找到则输出，否则进入它的原型对象</li>
<li>在原型对象的原型中的变量之间查找，如果找到则输出，否则输出undefined</li>
</ol>
<p>使用<strong>in语句</strong>来查找属性是否属于某个对象时会向它的原型中查找</p>
<p>如果不想查找原型中的属性，使用<code>hasOwnProperty</code>方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person.<span class="property">b</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> person);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;b&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>结果为true, false, true</p>
<p>当在页面中打印一个对象时，实际上输出的是这个对象的valueOf方法的返回值，因此可以通过修改对象的valueOf方法来修改打印对象时的结果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">valueOf</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;name = &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person);</span><br></pre></td></tr></table></figure>

<p>结果为name &#x3D; “a”        &#x2F;&#x2F;根据实际测试，结果与浏览器相关</p>
<p>当将对象强制转换成数字时会首先调用valueOf方法，当此方法返回自己时再调用toString</p>
<p>当对象强制转换成字符串时只调用toString方法</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>当创建对象之后对所有这个对象的变量赋值为null时，这个对象就永远无法被操作，这个对象就称为垃圾</p>
<p>js拥有自动的垃圾回收机制，不需要也不能手动地回收垃圾，能做的只有将不再使用的对象<strong>赋值为null</strong></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组也是一个<strong>对象</strong>，与对象的区别在于数组只能通过<strong>索引</strong>来查找值，并且存储效率要比普通对象更高，所以具有所有对象具有的特性</p>
<h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><p>var arr &#x3D; new Array();</p>
<p>arr具有三个对象属性</p>
<ol>
<li>constructor(构造函数的引用)</li>
<li>length(数组长度),</li>
<li>prototype(原型对象的引用)</li>
</ol>
<p>可以使用：</p>
<p>​        数组[数组.length] &#x3D; 值;</p>
<p>来方便地向数组最后一位添加内容</p>
<p>可以通过修改数组长度来删除一些数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">arr[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">arr.<span class="property">length</span> = <span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure>

<p>结果为undefined</p>
<p>当访问数组中不存在的数据时，会返回undefined而不是报错</p>
<p>可以使用数组字面量方便地创建数组</p>
<blockquote>
<p>​        语法：[]<br>​        var arr &#x3D; [];</p>
</blockquote>
<p>在数组字面量中可以直接加入参数来给数组赋值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure>

<p>结果为0,1,2,3</p>
<p>同样也能向数组类添加参数来直接给数组赋值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1);</span><br></pre></td></tr></table></figure>

<p>结果为0,1,2,3</p>
<p>但是当参数只有一个时，结果会有所不同</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>];         <span class="comment">//创建一个第一个值为10的数组</span></span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>);       <span class="comment">//创建一个长度为10的数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1);</span><br></pre></td></tr></table></figure>

<p>结果分别为10和,,,,,,,,,</p>
<h3 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h3><h4 id="1-push"><a href="#1-push" class="headerlink" title="1.push"></a>1.push</h4><p>向数组最后添加一个或多个元素并将数组长度返回</p>
<h4 id="2-pop"><a href="#2-pop" class="headerlink" title="2.pop"></a>2.pop</h4><p>删除数组最后一个元素并将该元素返回</p>
<h4 id="3-unshift"><a href="#3-unshift" class="headerlink" title="3.unshift"></a>3.unshift</h4><p>向数组开头添加一个或多个元素并将数组长度返回</p>
<h4 id="4-shift"><a href="#4-shift" class="headerlink" title="4.shift"></a>4.shift</h4><p>删除数组开头的元素并将该元素返回</p>
<h4 id="5-forEach"><a href="#5-forEach" class="headerlink" title="5.forEach"></a>5.forEach</h4><p>按顺序遍历整个数组</p>
<p>支持IE8以上或者其他的浏览器</p>
<p><strong>由自己创建但不由自己调用</strong>的函数称为<strong>回调函数</strong><br>​        语法：<br>​            数组.forEach(function(value, index, arr){</p>
<p>​        });</p>
<p> 它会在回调函数中以实参的形式传递3个参数：</p>
<ol>
<li>​    当前循环中的元素</li>
<li>​    当前循环中的索引</li>
<li>​    调用forEach函数的数组</li>
</ol>
<h4 id="6-slice"><a href="#6-slice" class="headerlink" title="6.slice"></a>6.slice</h4><p>从一个数组中截取特定范围的元素并将这些元素以数组的形式返回，不改变原数组</p>
<blockquote>
<p>​    语法：<br>​        数组.slice(start, end);</p>
</blockquote>
<p>第一个参数是截取开始的索引，返回数组会包括开始索引的元素</p>
<p>第二个参数是截取结束的索引，返回数组不会包括结束索引的元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr1 = arr.<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1);</span><br></pre></td></tr></table></figure>

<p>结果为0,1,2,3</p>
<p>参数可以是负值，如果为负就是从后往前计数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr1 = arr.<span class="title function_">slice</span>(-<span class="number">3</span>,-<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1);</span><br></pre></td></tr></table></figure>

<p>结果为3,4</p>
<h4 id="7-splice"><a href="#7-splice" class="headerlink" title="7.splice"></a>7.splice</h4><p>删除或者添加元素，直接改变原数组,返回值为删除的元素</p>
<blockquote>
<p>​    语法：<br>​        数组.splice(start, number[,元素1, 元素2…]);</p>
</blockquote>
<p>第一个参数为从哪个索引开始删除元素</p>
<p>第二个参数为删除几个元素</p>
<p>从第三个参数开始的参数都是是在第一个参数的索引之前添加这些元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure>

<p>结果为7,8,9,1,2,3,4,5</p>
<h4 id="8-concat"><a href="#8-concat" class="headerlink" title="8.concat"></a>8.concat</h4><p>可以将两个或者多个数组连接成一个数组</p>
<p>不会改变原数组</p>
<p>语法：<br>​        数组.concat(任意数据类型[，任意数据类型…]);</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> result = arr.<span class="title function_">concat</span>([<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],<span class="number">1</span>,<span class="string">&quot;a&quot;</span>, <span class="literal">false</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, &#123;&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure>

<p>结果为1,2,3,4,5,6,7,8,1,”a”,false,null,undefined,{}</p>
<h4 id="9-join"><a href="#9-join" class="headerlink" title="9.join"></a>9.join</h4><p>将数组中的元素转换成字符串，可以添加参数指定元素之间的连接符，无参数时默认为逗号,<br>不会改变原数组</p>
<blockquote>
<p>​    语法：</p>
<p>​			数组.join([字符串])；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> result = arr.<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure>

<p>结果为”1 2 3 4”</p>
<h4 id="10-reverse"><a href="#10-reverse" class="headerlink" title="10.reverse"></a>10.reverse</h4><p>调换数组中元素的排列顺序<br>会修改原数组，并且修改后的数组与返回值相同</p>
<blockquote>
<p>语法：<br>​        数组.reverse();</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> result = arr.<span class="title function_">reverse</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure>

<p>结果都为4,3,2,1</p>
<h4 id="11-sort"><a href="#11-sort" class="headerlink" title="11.sort"></a>11.sort</h4><ul>
<li><p>给数组中的元素排序，默认以unicode编码顺序排列，因此直接对数组中的数字排序会产生预料外的结果</p>
</li>
<li><p>可以传递一个回调函数作为sort的参数，回调函数中有两个形参分别表示数组中一前一后的两个元素，具体是哪两个元素需要根据循环确认</p>
</li>
<li><p>函数的返回值决定是否交换这个两个元素，当返回值大于0时交换，小于0时不交换，等于0时认为两个值相等不交换</p>
</li>
<li><p>会直接修改原数组的元素，与方法的返回值相同</p>
<blockquote>
<p>​    语法：<br>​        数组.sort([回调函数]);</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">767</span>,<span class="number">34</span>,<span class="number">2</span>];</span><br><span class="line">arr.<span class="title function_">sort</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure>

<p>结果为2,3,34,5,6,767</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure>

<p>结果为2,3,5,6,34,767</p>
</li>
</ul>
<h2 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h2><p>函数对象都具有这两个方法，可以向这两个方法中的第一个参数传入一个对象用来修改这个方法的this对象</p>
<p>如果函数对象需要形参, call方法中第二个参数开始依次输入要传递给函数对象的实参</p>
<p>将需要传递的实参封装成一个数组作为apply的第二个参数将实参传递给函数对象</p>
<blockquote>
<p>​    语法：<br>​        函数.call(对象[,参数1…]);<br>​        函数.apply(对象[,数组]);</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params">a</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>(<span class="number">1</span>);</span><br><span class="line">a.<span class="title function_">call</span>(obj, <span class="number">1</span>);</span><br><span class="line">a.<span class="title function_">apply</span>(obj, [<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<blockquote>
<p>window,1<br>object,1<br>object,1</p>
</blockquote>
<h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><ul>
<li>在调用函数时，浏览器还会隐式传递一个参数arguments，它是一个<strong>类数组对象</strong>，不是数组对象</li>
<li>使用索引来查询调用函数时传入的参数</li>
<li>拥有length属性来表示传入参数的数量</li>
<li>拥有callee属性表示当前指向的函数引用，可以用来编写递归函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">callee</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>​	结果为2,1,2,a函数本身</p>
<h2 id="global对象"><a href="#global对象" class="headerlink" title="global对象"></a>global对象</h2><ul>
<li>ECMAScript中非常特别的对象，理论上存在但是又无法获取. </li>
<li>不属于其他任何对象的属性或者对象都是这个对象的属性和方法</li>
<li>也就是说所有在全局作用域中定义的属性与对象可以说都是这个对象的属性和方法</li>
<li>ECMAScript没有指出如何访问global对象，但是浏览器会将这个对象当作window的一部分加以实现</li>
<li>常用方法：<br>​        1. encodeURL() 用来将整个url编码成浏览器能够识别的字符串，即将一些特殊字符进行编码，如：空格-&gt;%20，url中合法特殊字符不会被编码</li>
</ul>
<p>​        2. encodeURLComponent() 用来将某一段url编码成浏览器能够识别的字符串，url中合法特殊字符也会被编			码</p>
<p>​        3. decodeURL()   encodeURL的反向操作，规则与之相同</p>
<p>​        4. decodeURLComponent()  encodeURLComponent的反向操作，规则与之相同</p>
<h2 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h2><p>用来操作与时间有关的对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();      <span class="comment">//实例化Date对象的值就是执行这行代码时的时间</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;12/11/2016 0:0:0&quot;</span>);  <span class="comment">//当输入参数时以参数对应的含义输出时间，按照mm/dd/yyyy h:m:s的格式输入</span></span><br></pre></td></tr></table></figure>

<p>常用方法：</p>
<pre><code>    1. getDate() 获取时间的日
       2. getDay()  获取时间的星期，值为0-6，从周日计算
       3. getMonth() 获取时间的月份，值为0-11，从1月计算
       4. getFullYear() 获取时间的年份
       5. getTime() 获取时间的时间戳，为格林尼治标准时间1970/1/1 0:0:0开始到特定世界为止经过的毫秒
       6. Date.now();     //执行这行代码时的时间戳，可用来计算一段代码的性能
</code></pre>
<h2 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h2><p>Math对象与其他内建对象不同，它不是构造函数而是一个工具类，不需要实例化，直接使用</p>
<blockquote>
<p>​    语法：<br>​        Math.方法();</p>
</blockquote>
<p><strong>常用属性：</strong></p>
<p>​        E 自然对数<br>​        PI 圆周率</p>
<p><strong>常用方法：</strong></p>
<ol>
<li><p>ceil()<br>向上取整</p>
</li>
<li><p>floor()</p>
</li>
</ol>
<p>  向下取整</p>
<ol start="3">
<li>round()</li>
</ol>
<p>  四舍五入</p>
<ol start="4">
<li>random()</li>
</ol>
<p>  获取0-1之间的随机数<br>  当想获取x-y之间的随机数时有公式Math.random()*(y-x)+x</p>
<ol start="5">
<li>max()</li>
</ol>
<p>  获取多个数中的最大值</p>
<ol start="6">
<li>min()</li>
</ol>
<p>   获取多个数中的最小值</p>
<ol start="7">
<li>sqrt()</li>
</ol>
<p>  对某个数开根号</p>
<ol start="8">
<li>pow(x, y)</li>
</ol>
<p>  求x的y次幂       </p>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>js提供了3个包装类将3种基本数据类型转换成基本数据类型对象，但是在日常开发中不要使用这种方式，因为在转换后进行比较时会产生预期外的结果</p>
<p><strong>1.String</strong></p>
<p>​            将基本数据类型string转换成string对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> str);</span><br></pre></td></tr></table></figure>

<p>结果为object</p>
<p><strong>2.Number</strong></p>
<p>​            将基本数据类型number转换成number对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> num);</span><br></pre></td></tr></table></figure>

<p>​            结果为object</p>
<p><strong>3.Boolean</strong></p>
<p>​            将基本数据类型boolean转换成boolean对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bool = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> bool);</span><br></pre></td></tr></table></figure>

<p>​            结果为object</p>
<p>当对这三种基本数据类型操作包装类中的方法或者属性时，浏览器会临时创建一个基本数据类型对象再调用这些方法，然后再将其转换成基本数据类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">a.<span class="title function_">toString</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a);</span><br></pre></td></tr></table></figure>

<p>结果为string</p>
<p>执行这两行代码时不会报错，因为实际在对临时创建的基本数据类型对象进行属性赋值操作，语句执行完毕后临时对象就被销毁，因此第二次执行时结果为undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="property">name</span> = <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">name</span>);</span><br></pre></td></tr></table></figure>

<p>结果为undefined     </p>
<h2 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h2><p> string的底层是用字符数组进行表示的，因此许多数组可以使用的方法在字符串中同样可以使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>结果为”a”</p>
<p><strong>常用属性:</strong></p>
<p>​        length</p>
<p>​            表示字符串的长度</p>
<p><strong>常用方法：（全都不改变原字符串）</strong></p>
<p>​        1.charAt()</p>
<blockquote>
<p>​            返回指定位置的字符，与用索引表示相同</p>
</blockquote>
<p>​        2.charCodeAt()</p>
<blockquote>
<p>​            返回指定位置的字符unicode编码</p>
</blockquote>
<p>​        3.fromCharCode()</p>
<blockquote>
<p>​            返回指定unicode编码对应的字符</p>
</blockquote>
<p>​        4.concat()</p>
<blockquote>
<p>​            连接多个字符串，与使用加号+连接字符串相同</p>
</blockquote>
<p>​        5.indexOf()</p>
<blockquote>
<p>​            返回指定字符在字符串中第一次出现的索引，当没有时返回-1<br>​            参数：<br>​                第一个参数：需要查找的字符<br>​                第二个参数：从第几个索引开始进行查找</p>
</blockquote>
<p>​        6.lastIndexOf()</p>
<blockquote>
<p>​            与indexOf相似，但是它返回的是字符在字符串中最后一次出现的索引，没有时返回-1<br>​            参数：<br>​                第一个参数：需要查找的字符<br>​                第二个参数：从第几个索引开始进行查找</p>
</blockquote>
<p>​        7.toUpperCase()</p>
<blockquote>
<p>​            将所有字符转化成大写</p>
</blockquote>
<p>​        8.toLowerCase()</p>
<blockquote>
<p>​            将所有字符转化成大写</p>
</blockquote>
<p>​        9.slice()</p>
<blockquote>
<p>​            截取指定范围内的字符串，与数组中的slice相似<br>​            参数：<br>​                第一个参数：索引开始处，包括这个索引<br>​                第二个参数：索引结束处，不包括这个索引<br>​            参数可以是负数，当为负数时从字符串后往前数<br>​            不输入第二个参数时，截取第一个参数开始至后面全部的字符串<br>​                var str &#x3D; “abcdef”;<br>​                var result &#x3D; str.slice(0,-2);<br>​                console.log(result);<br>​            结果为”abcd”</p>
</blockquote>
<p>​        10.subString()</p>
<blockquote>
<p>​            与slice相似，不同在于参数为负数时默认输入是0，当第一个参数大于第二个参数时会交换两个参数的位置<br>​                var str &#x3D; “abcdef”;<br>​                var result &#x3D; str.subString(1, -3);<br>​                结果为”a”</p>
</blockquote>
<p>​        11.subStr()</p>
<blockquote>
<p>​            同样为截取一段字符串，与前两个方法的区别在于参数不同，这个方法不是ES标准，不推荐使用<br>​                参数：<br>​                第一个参数：索引开始处，包括这个索引<br>​                第二个参数：需要截取的字符数量</p>
</blockquote>
<p>​        12.split()</p>
<blockquote>
<p>​            与数组的join方法相反。将字符串以特定方式转换成数组<br>​                参数：<br>​                第一个参数：将字符串以哪个字符进行拆分充当新数组的元素<br>​                    var str &#x3D; “abtcdtef”;<br>​                    var result &#x3D; str.split(“t”);<br>​                    console.log(result);<br>​                    结果为ab,cd,ef<br>​                当参数为空串时，将每个字符都拆分成一个元素存入新数组<br>​                第二个参数：决定返回的数组长度</p>
</blockquote>
<h2 id="正则运算相关的方法"><a href="#正则运算相关的方法" class="headerlink" title="正则运算相关的方法"></a>正则运算相关的方法</h2><h3 id="正则表达式对象"><a href="#正则表达式对象" class="headerlink" title="正则表达式对象"></a>正则表达式对象</h3><p>用来匹配字符串是否满足要求</p>
<p>语法：</p>
<blockquote>
<p>​        var reg &#x3D; new RegExp(“正则表达式”, “匹配模式”);<br>​        匹配模式可以是<br>​        “i” —-忽略大小写<br>​        “g” —-全局匹配</p>
</blockquote>
<p>方法：    </p>
<blockquote>
<p>​        test()<br>​            测试指定字符串是否满足正则的匹配要求，满足返回true，否则返回false</p>
</blockquote>
<h3 id="正则表达式字面量"><a href="#正则表达式字面量" class="headerlink" title="正则表达式字面量"></a>正则表达式字面量</h3><p>语法：</p>
<blockquote>
<p>​            var reg &#x3D; &#x2F;正则表达式&#x2F;匹配模式;</p>
</blockquote>
<p>使用字面量更<strong>方便</strong>，使用构造函数更<strong>灵活</strong>，因为可以使用变量</p>
<p>正则表达式语法：<br>​        1.|<br>​            表示或<br>​            &#x2F;a|b&#x2F;.test(“ac”); &#x2F;&#x2F;true<br>​        2.[]<br>​            与|含义相同<br>​            &#x2F;[ab]&#x2F;.test(“bc”); &#x2F;&#x2F;true<br>​        3.[^]   &#x2F;&#x2F;忽略，有误<br>​            是否含有除了中括号外的内容<br>​            &#x2F;^ab&#x2F;.test(“ab”);  &#x2F;&#x2F;false<br>​        4. .<br>​            表示任意字符<br>​        5.<br>​            表示转义，将特殊符号转化成字符<br>​        6.*<br>​            表示0个或多个字符<br>​        7.+<br>​            表示1个或多个字符<br>​        8.^<br>​            表示开头的某个字符<br>​        9.$<br>​            表示结尾的某个字符<br>​        10.\w<br>​            表示任意字母数字_<br>​        11.\W<br>​            除了任意字母数字_<br>​        12.\d<br>​            表示任意数字<br>​        13.\D<br>​            除了任意数字<br>​        14.\s<br>​            表示空格<br>​        15.\S<br>​            除了空格<br>​        16.\b<br>​            表示单词分隔符<br>​        17.\B<br>​            除了单词分隔符<br>​        18.{}<br>​            限制字符出现的次数<br>​            &#x2F;^a{3,5}$&#x2F;.test(“aaaaaa”);    &#x2F;&#x2F;false<br>​        19.()<br>​            将几个字符当做整体<br>​            &#x2F;^(ab){2,3}$&#x2F;.test(“abababab”); &#x2F;&#x2F;false</p>
<p>   常用语法：</p>
<p>​            [a-z]   小写字母<br>​            [A-Z]   大写字母<br>​            [A-z]   英文字母<br>​            [0-9]   数字</p>
<h3 id="可以使用正则的字符串方法："><a href="#可以使用正则的字符串方法：" class="headerlink" title="可以使用正则的字符串方法："></a>可以使用正则的字符串方法：</h3><p>​        1.split()</p>
<p>​            将字符串以正则表达式作为间断符号拆分成数组<br>​                var str &#x3D; “1a2s3d4f5g6h7jk8”;<br>​                console.log(str.split(&#x2F;[1-9]&#x2F;));<br>​                结果为a,s,d,f,g,h,jk</p>
<p>​            正则不设置匹配模式为g也会全局拆分</p>
<p>​        2.search()</p>
<p>​            查询正则表达式中的字符位置，不存在则返回-1，与indexOf相似<br>​                var str &#x3D; “1a2s3d4f5g6h7jk8”;<br>​                console.log(str.search(&#x2F;[a-z]&#x2F;));<br>​                结果为0</p>
<p>​            正则设置匹配模式为g也不会全局匹配</p>
<p>​        3.match()</p>
<p>​            返回满足正则表达式匹配的字符<br>​                var str &#x3D; “1a2s3d4f5g6h7jk8”;<br>​                console.log(str.match(&#x2F;[a-z]&#x2F;));<br>​                结果为a</p>
<p>​            如果需要返回全局匹配的结果需要设置匹配模式为g，返回为数组<br>​                console.log(str.match(&#x2F;[a-z]&#x2F;g));<br>​                结果为a,s,d,f,g,h,j,k</p>
<p>​        4.replace()</p>
<p>​            将正则表达式匹配到的字符串用新字符串代替<br>​            参数：<br>​                第一个参数：需要被替换的原字符串，可以用正则表达式<br>​                第二个参数：需要替换的新字符串，可以是空串<br>​                var str &#x3D; “1a2s3d4f5g6h7jk8”;<br>​                console.log(str.replace(&#x2F;[a-z]&#x2F;, “!”));<br>​                结果为”1!2s3d4f5g6h7jk8”</p>
<p>​            如果需要返回全局匹配的结果需要设置匹配模式为g<br>​                console.log(str.replace(&#x2F;[a-z]&#x2F;g, “!”));<br>​                结果为”1!2!3!4!5!6!7!!8”</p>
<h2 id="DOM简介"><a href="#DOM简介" class="headerlink" title="DOM简介"></a>DOM简介</h2><p>​    DOM全称<strong>document object model</strong><br>​    <strong>文档</strong><br>​        整个HTML文件就是一个文档<br>​    <strong>对象</strong><br>​        HTML文件中的每个节点都在JS中是一个对象<br>​    <strong>模型</strong><br>​        JS使用模型来表示各个对象之间的关系</p>
<p>JS中有宿主对象document，它是window对象的属性，也就是文档对象本身</p>
<p>DOM中的对象又称为节点对象，共有4种节点分别为：​ </p>
<ol>
<li>文档节点</li>
<li>元素节点</li>
<li>属性节点</li>
<li>文本节点</li>
</ol>
<p>每个节点中都拥有三个属性分别是:</p>
<ol>
<li>nodeName</li>
<li>nodeType</li>
<li>nodeValue</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>nodeName</th>
<th>nodeType</th>
<th>nodeValue</th>
</tr>
</thead>
<tbody><tr>
<td>文档节点</td>
<td>#document</td>
<td>9</td>
<td>null</td>
</tr>
<tr>
<td>元素节点</td>
<td>标签名</td>
<td>1</td>
<td>null</td>
</tr>
<tr>
<td>属性节点</td>
<td>属性名</td>
<td>2</td>
<td>属性值</td>
</tr>
<tr>
<td>文本节点</td>
<td>#text</td>
<td>3</td>
<td>文本内容</td>
</tr>
</tbody></table>
<h3 id="常用属性："><a href="#常用属性：" class="headerlink" title="常用属性："></a>常用属性：</h3><p>​    1.body<br>​        该属性封装的是body元素对象的引用</p>
<p>​    2.documentElement<br>​        属性值为HTML元素对象</p>
<p>​    3.all<br>​        属性值为当前页面中的所有元素节点的数组<br>​        这个属性值本身为undefined，它的typeof值也为undefined</p>
<p>​    4.URL<br>​        获取当前页面的url</p>
<p>​    5.domain<br>​        获取当前页面的域名部分</p>
<p>​    6.referrer<br>​        获取是哪个页面链接跳转到当前页面，没有则返回空字符串</p>
<h3 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h3><p>​    语法：<br>​        document.方法();</p>
<p>​    <strong>1.getElementById()</strong><br>​        通过ID值获取对应的节点<br>​        IE8中不区分大小写<br>​        IE7中会匹配表单元素的name值</p>
<p>​    <strong>2.getElementsByTagName()</strong><br>​        通过标签名获取一组节点<br>​        返回值是一个HTMLCollection，即使只获取到一个节点时，也封装成HTMLCollection返回</p>
<p>​    <strong>3.getElementsByName()</strong><br>​        通过name的值获取一组节点<br>​        返回值是一个nodelist，与数组相似，可以使用forEach方法，即使只获取到一个节点时，也封装成nodelist返回</p>
<p>​    <strong>4.getElementsByClassName()</strong><br>​        通过class属性获取一组节点<br>​        返回值是一个HTMLCollection，即使只获取到一个节点时，也封装成HTMLCollection返回<br>​        仅支持IE8以上</p>
<p><strong>​    5.querySelector()</strong><br>​        通过CSS选择器返回一个节点，当能匹配多个节点时，返回满足匹配的第一个节点<br>​        仅支持IE7以上</p>
<p>​    <strong>6.querySelectorAll()</strong><br>​        通过CSS选择器返回一组节点<br>​        返回值是一个nodelist，与数组相似，可以使用forEach方法，即使只获取到一个节点时，也封装成nodelist返回<br>​        仅支持IE7以上</p>
<p>​    HTMLCollection：支持通过索引或者字符串来查找需要的节点，在后台则分别使用它的item()与namedItem()方法来获取</p>
<p>​    NodeList: 与HTMLCollection类似的一个node集合，他们的值都是动态的，每次去取这些值的属性都会引发一次文档查询，因此需要尽量减少直接访问﻿js输出</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>当用户与浏览器进行任何交互时都会产生相应的事件</p>
<p>JS可以通过给事件绑定相应函数来使事件触发时执行相应的函数,相应函数会在执行事件时才会被执行，因此相应函数内部使用的变量可能会与预期不一致</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementByTagName</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; div.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    div[i].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果永远会是div的长度的值<br>绑定事件有两种方法：<br>第一种：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;a&#x27;)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 结构与行为耦合，不使用  </p>
<p>第二种：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;a&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>       </span><br></pre></td></tr></table></figure>

<h4 id="常用方式"><a href="#常用方式" class="headerlink" title="常用方式"></a><strong>常用方式</strong></h4><p>文档加载顺序</p>
<p>​    浏览器加载HTML文件时是自上向下加载，因此当js代码写在文档之前时可能需要无法获取到节点的情况<br>​    使用<strong>window.onload</strong>绑定响应函数可以使响应函数内的代码都在整个文档加载完成之后执行<br>​    或者将JS代码<strong>写在HTML文档的最后</strong>来保证文档先于JS代码加载</p>
<p>元素节点</p>
<p>​    元素节点拥有一个方法和属性来获取它们内部的节点,除了元素的class属性以外,所有的属性都可以以元素节点对象属性的方式获取,<strong>class的值需要用className属性来获取</strong>，因为class是js中的保留字</p>
<h4 id="常用方法：-1"><a href="#常用方法：-1" class="headerlink" title="常用方法："></a><strong>常用方法：</strong></h4><p>​        <strong>1.getElementById()</strong><br>​            通过ID值获取当前元素节点内部对应的节点</p>
<p>​        <strong>2.getElementsByTagName</strong>()<br>​            用来获取当前元素节点内部的特定标签的元素节点<br>​            返回值是一个HTMLCollection，与数组相似，不能使用forEach方法，即使只获取到一个节点时，也封装成HTMLCollection返回</p>
<p>​        <strong>3.getElementsByName()</strong><br>​            通过name的值获取当前元素节点内部的一组节点<br>​            返回值是一个nodelist，与数组相似，可以使用forEach方法，即使只获取到一个节点时，也封装成nodelist返回</p>
<p>​        <strong>4.getElementsByClassName()</strong><br>​            通过class属性获取当前元素节点内部的一组节点<br>​            返回值是一个HTMLCollection，与数组相似，不能使用forEach方法，即使只获取到一个节点时，也封装成HTMLCollection返回<br>​            仅支持IE8以上</p>
<p>​        <strong>5.querySlector()</strong>**<br>​            通过CSS选择器返回当前元素节点内部的一个节点，当能匹配多个节点时，返回满足匹配的第一个节点<br>​            仅支持IE7以上</p>
<p>​        <strong>6.querySlectorAll()</strong><br>​            通过CSS选择器返回当前元素节点内部的一组节点<br>​            返回值是一个nodelist，与数组相似，可以使用forEach方法，即使只获取到一个节点时，也封装成nodelist返回<br>​            仅支持IE7以上</p>
<p>​        <strong>7.hasChildNodes()</strong><br>​            返回当前节点内部是否拥有1个或多个子节点</p>
<h4 id="常用属性：-1"><a href="#常用属性：-1" class="headerlink" title="常用属性："></a><strong>常用属性：</strong></h4><p>​        innerHTML<br>​            获取当前元素节点中的HTML代码</p>
<p>​        innerText<br>​            获取当前元素节点中的文本</p>
<p>​        childNodes<br>​            获取当前元素节点中所有的子节点并以数组形式返回，按照ES标准如果当前元素节点中有空格时也会被包括在内<br>​            IE8及以下浏览器没有实现这一标准，因此只会获取到内部的元素节点</p>
<p>​        children<br>​            获取当前元素节点中的所有子元素节点</p>
<p>​        firstChild<br>​            获取当前元素节点中的第一个子节点</p>
<p>​        firstElementChild<br>​            获取当前元素节点中的第一个子元素节点, 仅支持IE8以上</p>
<p>​        lastChild<br>​            获取当前元素节点中的最后一个子节点</p>
<p>​        lastElementChild<br>​            获取当前元素节点中的最后一个子元素节点, 仅支持IE8以上</p>
<p>​        parentNode<br>​            获取当前元素节点的父节点</p>
<p>​        previousSibling<br>​            获取当前元素节点的前一个兄弟节点</p>
<p>​        previousElementSibling<br>​            获取当前元素节点的前一个兄弟元素节点, 仅支持IE8以上</p>
<p>​        nextSibling<br>​            获取当前元素节点的后一个兄弟节点</p>
<p>​        nextElementSibling<br>​            获取当前元素节点的后一个兄弟元素节点, 仅支持IE8以上<br>​    当响应函数给某个节点绑定时，这个响应函数中的this就是这个节点</p>
<h3 id="DOM的增删改"><a href="#DOM的增删改" class="headerlink" title="DOM的增删改"></a>DOM的增删改</h3><p>​    常用方法：<br>​        1.createElement()<br>​            新建一个元素节点，参数是元素节点的标签名<br>​            语法:<br>​                document.createElement(“标签名”);</p>
<p>​        2.createTextNode()<br>​            新建一个文本节点，参数是文本节点的内容<br>​            语法:<br>​                document.createTextNode(“文本内容”);</p>
<p>​        3.appendChild()<br>​            向一个父节点中添加一个子节点<br>​            语法：<br>​                父节点.appendChild(子节点);</p>
<p>​        4.insertBefore()<br>​            向一个子节点前添加一个新的节点<br>​            语法：<br>​                父节点.insertBefore(新节点, 原节点);</p>
<p>​        5.removeChild()<br>​            移除一个子节点<br>​            语法：<br>​                父节点.removeChild(子节点);</p>
<p>​        6.replaceChild()<br>​            将原节点替换成新节点<br>​            语法：<br>​                父节点.replaceChild(新节点, 原节点);</p>
<p>​        7.cloneNode()<br>​            返回值是一个节点的拷贝，接受一个布尔值作为参数，true则为深度拷贝，false为浅拷贝<br>​            语法1：<br>​                节点:cloneNode(boolean)</p>
<p>​        8.normalize()<br>​            返回一个经过一定处理后的节点, 这个过程会合并文本节点并删除空白的文本节点</p>
<p>​        9.splitText(str)<br>​            返回一个按照参数进行分割的多个文本节点, 此方法<strong>只可被用于文本节点</strong></p>
<p>​    由于许多方法都要通过<strong>父节点调用</strong>对应的方法来操作节点，因此可使用：<br>​        <strong>子节点.parentNode.removeChild(子节点);</strong><br>​    类似的方法来对节点进行直接操作而不需要获取它的父节点</p>
<p>​    对DOM的增删改操作可以用父节点的innerHTML的字符串操作来代替，由于是整体修改所以这个父节点包括它的子节点绑定的函数都会失效<br>代码1：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;checkallbox&quot;</span>/&gt;</span>AAAAA</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> input = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;input&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> checkallbox = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;checkallbox&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">input.<span class="property">type</span>=<span class="string">&quot;checkbox&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">checkallbox.<span class="property">parentNode</span>.<span class="title function_">insertBefore</span>(input, checkallbox);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>代码2:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;checkallbox&quot;</span>/&gt;</span>AAAAA</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementByTagName</span>(<span class="string">&quot;div&quot;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">            div = <span class="string">&quot;&lt;input type=&#x27;checkbox&#x27;/&gt;&quot;</span> + div.<span class="property">innterHTML</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>   </span><br></pre></td></tr></table></figure>

<p>两部分代码功能基本相同，唯一区别是如果input标签绑定了响应函数，在代码2中会失效</p>
<h3 id="DOM的遍历"><a href="#DOM的遍历" class="headerlink" title="DOM的遍历"></a>DOM的遍历</h3><p>​    document.createNodeIterator(root, whatToShow, filter, entityReferenceExpansion)</p>
<p>​        参数一: 指定开始遍历的根节点，只能遍历body标签中的节点，其他标签会被跳过</p>
<p>​        参数二: 标识要访问标签元素的哪些节点，它是一个数字代码，语义化信息保存在NodeFilter类型中</p>
<blockquote>
<p>​                NodeFilter.SHOW_ALL         显示所有节点<br>​                NodeFilter.SHOW_ELEMENT     显示元素节点<br>​                NodeFilter.SHOW_ATTRIBUTE   显示属性节点<br>​                NodeFilter.SHOW_TEXT        显示文本节点<br>​                NodeFilter.SHOW_DOCUMENT    显示文档节点<br>​                NodeFilter.SHOW_COMMENT     显示注释节点</p>
</blockquote>
<p>​        参数三: 是一个NodeFilter对象，或者一个返回接受或者拒绝特定标签的函数<br>​                NodeFilter对象是一个只有acceptNode方法的对象，该方法是一个迭代回调函数，有一个node参数，迭代器中有几个节点则会被执行几次</p>
<p>​                返回值应是NodeFilter.FILTER_ACCEPT或者NodeFilter.FILTER_SKIP</p>
<p>​                通过返回值来判断是否能够访问当前回调函数中的标签元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> filter = &#123;</span><br><span class="line">    <span class="attr">acceptNode</span>: <span class="keyword">function</span>(<span class="params">node</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> node.<span class="property">tagName</span>.<span class="title function_">toLowerCase</span>() == <span class="string">&quot;p&quot;</span> ? <span class="title class_">NodeFilter</span>.<span class="property">FILTER_ACCEPT</span> : <span class="title class_">NodeFilter</span>.<span class="property">FILTER_SKIP</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​                也可以是一个与acceptNode方法相似的函数</p>
<p>​        参数四: 标识是否要扩展实体引用，在html中没有意义</p>
<p>​        nodeIterator有两个方法nextNode()与previousNode()来访问迭代器中的节点</p>
<ul>
<li>​        刚创建好的迭代器一开始是指向一个标识根节点的指针，第一次调用nextNode会指向第一个子节点</li>
<li>​        当越界时返回值为null</li>
<li>​        支持IE9+和其他浏览器</li>
</ul>
<p>​    document.createTreeWalker(root, whatToShow, filter, entityReferenceExpansion)</p>
<p>​        可以实现在经过过滤的root节点中任意跳跃，非常灵活</p>
<p>​        参数与上一个函数一致，唯一有区别的在于第三个参数的Nodefilter函数增加一个有效的返回值NodeFilter.FILTER_REJECT<br>​        此时迭代器会跳过这个节点及其后代元素而不是像NodeFilter.FILTER_SKIP那样单纯跳过当前节点，仍然进行深度遍历<br>​        在createNodeIterator的第三个参数中返回NodeFilter.FILTER_REJECT作用与NodeFilter.FILTER_SKIP相同</p>
<p>​        相较于NodeIterator对象，TreeWalker对象多出一些重要方法:</p>
<blockquote>
<p>​            parentNode()<br>​            firstChild()<br>​            lastChild()<br>​            nextSibling()<br>​            previousSibling()</p>
</blockquote>
<p>​        通过这些方法可以实现在TreeWalker对象中任意跳转到目标元素</p>
<p>​        W3C标准DOM2，但是IE不支持</p>
<h3 id="DOM范围"><a href="#DOM范围" class="headerlink" title="DOM范围"></a>DOM范围</h3><p>​    可以通过范围来选择文档中的一个区域而不必考虑节点的界限(选择在后台完成，对用户是不可见的)<br>​    以下属性可以获取到当前范围在文档中的位置信息<br>​        startContainer<br>​            包含范围起点的节点，即起点的父节点<br>​        startOffset<br>​            范围起点在startContainer中的偏移量<br>​            如果起点是文本节点，注释节点，cdata节点则值是范围起点节点距离startContainer需要跳过的字符串<br>​            如果起点是元素节点，则值是范围起点节点在startContainer中的子节点索引<br>​        endContainer<br>​            包含范围终点的节点，即终点的父节点<br>​        endOffset<br>​            范围终点在startContainer中的位置<br>​            值计算规则与startOffset相同<br>​        commonAncestorContainer<br>​            起点节点与终点节点共同的最近的那个祖先节点<br>​    通过以下方法可以进行选择范围操作<br>​        selectNode<br>​            选中传入参数的那个节点及内部节点<br>​        selectNodeContents<br>​            选中传入参数的那个节点的内部节点<br>​        setStartBefore(refnode)<br>​            将范围起点设置为refnode之前，refnode就成为了范围选区的第一个节点<br>​            startContainer变成refnode的父节点，startOffset的值变成refnode在父节点中的索引<br>​        setStartAfter(refnode)<br>​            将范围起点设置为refnode之后，refnode就成为了范围选区外的节点，下一个节点是范围选区内第一个节点<br>​            startContainer变成refnode的父节点，startOffset的值变成refnode在父节点中的索引加1<br>​        setEndBefore(refnode)<br>​            将范围终点设置为refnode之前，refnode就成为了范围选区的最后一个节点<br>​            startContainer变成refnode的父节点，startOffset的值变成refnode在父节点中的索引<br>​        setEndAfter(refnode)<br>​            将范围起点设置为refnode之后，refnode就成为了范围选区外的节点，下一个节点是范围选区内第一个节点<br>​            startContainer变成refnode的父节点，startOffset的值变成refnode在父节点中的索引加1<br>​        setStart()<br>​            传入两个参数，第一个参数是参照节点，第二个参数是偏移量<br>​            参照节点会被当做startContainer,偏移量会变成startOffset<br>​        setEnd()<br>​            传入两个参数，第一个参数是参照节点，第二个参数是偏移量<br>​            参照节点会被当做endContainer,偏移量会变成endOffset<br>​    创建范围之后可以使用以下方法对选中内容进行操作<br>​        deleteContents()<br>​            将选中的内容从文档中删除<br>​        extractContents()<br>​            将选中的内容从文档中提取出来并作为返回值返回<br>​        cloneContents()<br>​            拷贝一份选中的内容并作为返回值返回<br>​        insertNode()<br>​            将一个节点插入到范围的最开始处<br>​        surroundContents()<br>​            将范围内容插入到这个节点之内<br>​        collapse()<br>​            可以将选中的范围进行折叠，使范围起点与终点都指向同一个位置<br>​            传入一个布尔值作参数，true表示折叠到原范围的起点，false表示折叠到原范围的终点<br>​        compareBoundaryPoints()<br>​            传入两个参数，第一个参数是需要比较哪两个点的一个常量，值可以是Range.START_TO_START,Range.START_TO_END,Range.END_TO_START,Range.END_TO_END<br>​            第二个参数是需要比较的范围，如果调用这个方法的范围与传入的范围的需要比较的点是前者在前则返回-1，相同返回0，前者在后则返回1<br>​        detach()<br>​            在使用完范围后最好使用此方法来使范围从文档中分离，然后再删除引用，方便垃圾回收机制清理<br>IE8及以下的文本范围<br>​    创建文本范围<br>​        在input，button，textarea，body等几个元素可以使用createTextRange来创建文本节点<br>​    选取文本范围<br>​        findText()<br>​            传入一个字符串参数，如果找到了对应的范围则返回值为true否则为false同时让范围包围这段文本<br>​        moveToElementText()<br>​            传入一个DOM节点，让范围包含这个节点的文本信息与标签信息，与selectNode作用类似<br>​        move()<br>​        moveStart()<br>​        moveEnd()<br>​        expand()<br>​            这些方法都传入两个参数，第一个参数是移动单位，第二个参数是移动单位的数量<br>​            移动单位可以是以下值<br>​                character：逐个字符移动<br>​                word：逐个单词移动<br>​                sentence： 逐个句子(一系列以叹号问号句号结尾的字符)移动<br>​                textedit：移动到当前选区开始或结束的位置<br>​        move会将范围折叠<br>​        expand会将部分文本的范围变成完整文本的范围<br>​    修改范围内的内容<br>​        有text与pasteHTML()<br>​        前者改变文本，后者可以包括标签<br>​    折叠范围<br>​        与其他浏览器相同使用collapse()来折叠范围<br>​        但是没有collapsed属性来判断是否折叠，但是可以使用boundingWidth属性来判断范围宽度是否为0<br>​    比较范围<br>​        compareEndPoints()<br>​            用法与作用同compareBoundaryPoints类似<br>​            第一个参数是字符串，表示需要比较哪两个点如: StartToEnd等格式<br>​            第二个参数是待比较的范围<br>​    复制范围<br>​        duplicate()<br>​            作用与cloneContents()相同</p>
<h3 id="操作样式"><a href="#操作样式" class="headerlink" title="操作样式"></a>操作样式</h3><p>​    在css的属性中如果有用-来间接的情况，在style需要使用<strong>驼峰命名法</strong>来修改属性名从而设置或者读取对应的样式</p>
<p>​    1.style</p>
<blockquote>
<p>​        语法：<br>​            节点对象.style.属性值</p>
</blockquote>
<p>​        通过这个属性能够修改和读取到节点的<strong>内联样式</strong>，当节点没有内联样式时获取到的是空字符串</p>
<p>​        如果在其他地方的css样式中设置了!important，那么通过js操作这个属性会失效</p>
<p>​    2.currentStyle<br>​        此属性<strong>只能在IE浏览器</strong>中使用并且是<strong>只读</strong>的，当未给某个节点设置长度值时会返回auto</p>
<blockquote>
<p>​        语法：<br>​            节点对象.currentStyle.属性值</p>
</blockquote>
<p>​    3.getComputedStyle()</p>
<p>​        此方法是window的方法，可以直接使用，而且也是<strong>只读</strong>的</p>
<p>​        在获取width属性时当未设置具体样式的情况下，会返回节点对象实际呈现的结果而不是auto</p>
<blockquote>
<p>​        语法：<br>​            getComputedStyle(节点对象, 伪元素（常设置为null）)[样式名]</p>
</blockquote>
<p>​        此方法支持IE8以上以及其他浏览器</p>
<p>​    <strong>常用属性：</strong></p>
<p>​        1.clientHeight<br>​            获取元素的<strong>视图高度</strong>，包括元素的内容高度与内边距高度，返回值是一个数字，<strong>只读</strong>, 在根标签的此属性就是指代视口大小，与此规则无关</p>
<p>​        2.clientwidth<br>​            获取元素的<strong>视图宽度</strong>，包括元素的内容宽度与内边距宽度，返回值是一个数字，<strong>只读</strong>, 在根标签的此属性就是指代视口大小，与此规则无关</p>
<p>​        3.offsetHeight<br>​            获取元素的真实高度，包括元素的内容高度，内边距高度与<strong>边框高度</strong>，当被父元素隐藏或者滚动时不会影响这个值，返回值是一个数字，<strong>只读</strong>，在IE11以下浏览器中的根标签的此属性就是指代视口大小，与此规则无关</p>
<p>​        4.offsetWidth<br>​            获取元素的真实宽度，包括元素的内容宽度，内边距宽度与<strong>边框宽度</strong>，当被父元素隐藏或者滚动时不会影响这个值，返回值是一个数字，<strong>只读</strong>，在IE11以下浏览器中的根标签的此属性就是指代视口大小，与此规则无关</p>
<p>​        5.offsetParent<br>​            获取当前元素的定位父元素，即<strong>设置了position的最近父元素</strong>，当所有父元素都没有设置时，返回<strong>body</strong>元素, 但是在除了火狐的浏览器中当position设置为fixed，返回null. </p>
<p>​            在IE7包括IE7时，position为absolute与relative时返回html，body与html间的margin清除后可看做body. 在IE7以下时当祖先元素开启hasLayout返回最近开启的元素</p>
<p>​        5.offsetTop<br>​            获取当前元素<strong>相对于定位父元素</strong>的上侧偏移量(相对于offsetParent的内边距)，即使父元素自身有偏移量也不改变这个值的大小，返回值是一个数字，<strong>只读</strong></p>
<p>​        6.offsetLeft<br>​            获取当前元素<strong>相对于定位父元素</strong>的左侧偏移量(相对于offsetParent的内边距)，即使父元素自身有偏移量也不改变这个值的大小，返回值是一个数字，<strong>只读</strong></p>
<p>​        7.scrollHeight<br>​            获取当前元素的真实高度,包括元素的内容高度与内边距高度，当被父元素隐藏或者滚动时不会影响这个值，返回值是一个数字，<strong>只读</strong></p>
<p>​        8.scrollWidth<br>​            获取当前元素的真实宽度,包括元素的内容宽度与内边距宽度，当被父元素隐藏或者滚动时不会影响这个值，返回值是一个数字，<strong>只读</strong></p>
<p>​        9.scrollTop<br>​            获取当前元素的右侧滚动条滚动的像素，返回值是一个数字，<strong>只读</strong></p>
<p>​        10.scrollLeft<br>​            获取当前元素的下侧滚动条滚动的像素，返回值是一个数字，<strong>只读</strong></p>
<p>​        <strong>公式：scrollHeight - scrollTop &#x3D; clientHeight 可以证明滚动条滚动到最底端</strong></p>
<p>​		11.getBoundingClientRect</p>
<p>​			基于border-box<br>​			获取一个元素四个角的相对位置与高宽, 在IE7及以下没有width与height属性<br>​			获取绝对位置可以让相对位置加上滚动的像素</p>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>当给某个元素对象绑定响应函数后，浏览器在执行这个响应函数后会向这个函数自动传递一个实参，该实参封装了与此事件有关的任何数据</p>
<p>可以给响应函数添加形参来调用这个事件对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">            <span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementByTagName</span>(<span class="string">&quot;div&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">            div.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IE8及以下浏览器不会传递此实参，因此会无法获取到</p>
<p>IE与chrome浏览器也会将这个实参保存在window.event中，可以用来兼容IE8及以下浏览器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementByTagName</span>(<span class="string">&quot;div&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">div.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line">    event = event || <span class="variable language_">window</span>.<span class="property">event</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>浏览器的滚动条在chrome中被认为是<code>documentElement</code>的<code>scrollTop</code>和<code>scrollLeft</code>的值，而在IE与firefox被认为是<code>body</code>的<code>scrollTop</code>和<code>scrollLeft</code>的值</p>
<p>因此可以使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scrollTop = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span>;</span><br><span class="line"><span class="keyword">var</span> scrollLeft = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollLeft</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollLeft</span>;</span><br></pre></td></tr></table></figure>

<p>来兼容三种浏览器</p>
<h4 id="常用属性：-2"><a href="#常用属性：-2" class="headerlink" title="常用属性："></a>常用属性：</h4><p>​    1.clientX</p>
<p>​        返回触发此事件时鼠标在视图中的X坐标</p>
<p>​    2.clientY</p>
<p>​        返回触发此事件时鼠标在视图中的Y坐标</p>
<p>​    3.pageX</p>
<p>​        返回触发此事件时鼠标在触发此事件的元素中的X坐标，仅支持IE8以上及其他浏览器</p>
<p>​    4.pageY</p>
<p>​        返回触发此事件时鼠标在触发此事件的元素中的Y坐标，仅支持IE8以上及其他浏览器</p>
<ul>
<li><p>IE浏览器的浏览器默认行为**不能使用return false;**来阻止某些浏览器默认行为如文字拖拽</p>
</li>
<li><p>在IE浏览器中可以设置obj.setCapture来让所有的操作都被设置的obj捕获，其他对象就不会执行任何响应函数</p>
</li>
<li><p>同样可以设置document.releaseCapture来取消事件捕获,这个可以与其他浏览器的在响应函数中return false;一起使用来达到取消浏览器默认行为的作用</p>
</li>
<li><p>return false与event.returnValue&#x3D;false作用相同</p>
</li>
<li><p>对于其他默认行为由于IE不支持event.preventDefault，因此可以使用 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">event.<span class="property">preventDefault</span> &amp;&amp; event.<span class="title function_">preventDefault</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>来做到兼容所有浏览器</p>
</li>
<li><p>当事件由<code>addEventListener</code>绑定时，不能使用return false取消默认行为而需要<strong>event.preventDefault</strong>，对于不支持此方法的IE，使用event.returnValue&#x3D;false</p>
</li>
</ul>
<h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>​    当某个元素的事件触发时，相同的事件会一层层向这个元素的父元素传递</p>
<p>​    是否传递是根据dom树结构来决定而不是页面上是否包裹，只要是父元素，不管是否与子元素重叠都会将子元素的事件冒泡给父元素</p>
<p>​	如果不希望这个元素向外进行事件冒泡有两种方法来取消冒泡</p>
<p>​    1.event.cancelBubble&#x3D;true<br>​        不属于W3C标准，但是更方便，新版本的chrome与firefox都已经支持</p>
<p>​    2.event.stopPropogation()<br>​        W3C标准，但是IE不支持</p>
<p>​    示例代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">                    <span class="selector-id">#outer</span>&#123;</span></span><br><span class="line"><span class="language-css">                        <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">                        <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">                        <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">                        <span class="attribute">border</span>: <span class="number">20px</span> solid gray;</span></span><br><span class="line"><span class="language-css">                        <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="language-css">                        <span class="attribute">position</span>:relative;</span></span><br><span class="line"><span class="language-css">                    &#125;</span></span><br><span class="line"><span class="language-css">                    <span class="selector-id">#inner</span>&#123;</span></span><br><span class="line"><span class="language-css">                        <span class="attribute">width</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">                        <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">                        <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">                        <span class="attribute">border</span>: <span class="number">20px</span> solid <span class="built_in">rgb</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span></span><br><span class="line"><span class="language-css">                        <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="language-css">                        <span class="attribute">position</span>:relative;</span></span><br><span class="line"><span class="language-css">                    &#125;</span></span><br><span class="line"><span class="language-css">                    <span class="selector-id">#content</span>&#123;</span></span><br><span class="line"><span class="language-css">                        <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">                        <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">                        <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">                        <span class="attribute">border</span>: <span class="number">20px</span> solid red;</span></span><br><span class="line"><span class="language-css">                        <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">                    &#125;</span></span><br><span class="line"><span class="language-css">                </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">window</span>.<span class="property">onload</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">var</span> outer = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;outer&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">var</span> inner = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;inner&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">var</span> content = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;content&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                        content.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="title function_">alert</span>(<span class="string">&quot;content&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                        &#125;;</span></span><br><span class="line"><span class="language-javascript">                        inner.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="title function_">alert</span>(<span class="string">&quot;inner&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                            event.<span class="property">cancelBubble</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">                        &#125;;</span></span><br><span class="line"><span class="language-javascript">                        outer.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="title function_">alert</span>(<span class="string">&quot;outer&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                        &#125;;</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">            </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;inner&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    结果为弹出两个框分别为content与inner</p>
<h3 id="事件委派"><a href="#事件委派" class="headerlink" title="事件委派"></a>事件委派</h3><p>​    当在给节点添加新节点并且需要让这个新节点与其他兄弟节点有同样的响应函数时可以使用事件委派的功能</p>
<p>​    当事件触发时响应函数的形参属性event.target会指定实际触发此函数的节点</p>
<p>​    将响应函数绑定到父元素上，并且使用响应函数的形参的属性进行节点判断可以完成新增子节点不需要重新绑定响应函数的功能</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">var</span> ul = <span class="variable language_">document</span>.<span class="title function_">getElementByTagName</span>(<span class="string">&quot;ul&quot;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">as</span>[i].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">if</span>(event.<span class="property">target</span>.<span class="property">className</span> == <span class="string">&quot;a&quot;</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="title function_">alert</span>(<span class="string">&quot;我是a&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                        &#125;</span></span><br><span class="line"><span class="language-javascript">                    &#125;;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><p>​    当对同一个节点的事件重复绑定响应函数时后绑定的函数会覆盖前绑定的函数导致前绑定的函数不会被执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line">a.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​        结果为2</p>
<p>​    使用addEventListener来为节点添加监听函数，响应函数<strong>可以绑定多次</strong>，并且会<strong>按顺序执行</strong>,支持IE8以上或者其他的浏览器，响应函数内部的this是<strong>节点对象</strong><br>​    解绑使用removeEventListener</p>
<p>​        参数：<br>​            –事件名，<strong>不带on</strong><br>​            –响应函数<br>​            –布尔值，决定事件是否在捕获阶段执行，默认为false，在冒泡阶段执行</p>
<p>​        语法：<br>​            对象.addEventListener(“”, 响应函数, false&#x2F;true)</p>
<p>​    想要兼容IE8及以下浏览器时使用attachEvent，同样可以<strong>绑定多次</strong>，但是顺序为<strong>后绑定先执行</strong>，响应函数内部的this是<strong>window</strong><br>​    解绑使用detatchEvent</p>
<p>​        参数：<br>​            –事件名，带on<br>​            –响应函数</p>
<p>​        语法：<br>​            对象.addEventListener(“”, 响应函数)</p>
<p>​    可以定义一个bind函数来兼容两者</p>
<p>​        参数：<br>​            –需要绑定响应函数的节点对象<br>​            –事件名，不带on<br>​            –响应函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bind</span>(<span class="params">obj, eventStr, func</span>)&#123;</span><br><span class="line">    obj.<span class="property">addEventListener</span> ? obj.<span class="title function_">addEventListener</span>(eventStr, func) : obj.<span class="title function_">attachEvent</span>(<span class="string">&quot;on&quot;</span> + eventStr, <span class="keyword">function</span>(<span class="params"></span>)&#123;func.<span class="title function_">call</span>(obj)&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h3><p>​    浏览器在实现时对于事件传播微软与网景有不同的理解方式</p>
<p>​    –微软认为事件由子元素向父元素传播</p>
<p>​    –网景认为事件由父元素向子元素传播</p>
<p>​    W3C标准实现时参考两种方法给出了事件执行的阶段：</p>
<p>​    –<strong>捕获阶段</strong></p>
<p>​        事件先从父元素向子元素传递</p>
<p>​    –<strong>目标阶段</strong></p>
<p>​        捕获阶段完成后事件在目标阶段执行</p>
<p>​    –<strong>冒泡阶段</strong></p>
<p>​        然后事件再从子元素向父元素传递</p>
<p>​    当需要设置某个事件在捕获阶段执行时，将addEventListener()的第三个参数设置为true即可，IE8及以下浏览器没有实现捕获阶段所以没有办法设置<br>一些事件</p>
<p>​    1.onmousewheel</p>
<p>​        当鼠标滚轮滑动时触发此事件，事件结果由event.wheelDelta返回<strong>向上滚时返回120，向下滚时返回-120</strong>，可以<strong>只关注正负</strong>，同时不被firefox支持</p>
<p>​        想在firefox中监听此事件需要使用addEventListener(“DOMMouseScroll”, func)来监听鼠标滚轮的操作，事件结果由event.detail返回，向上滚动时返回-3，向下滚动时返回3</p>
<p>​        当浏览器中有滚动条时鼠标滚动操作会默认滚动滚动条，在IE与chrome中可以使用return false来取消默认行为，firefox需要使用preventDefault来取消</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="property">onmousewheel</span> = <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line">    event = event || <span class="variable language_">window</span>.<span class="property">event</span>;</span><br><span class="line">    <span class="keyword">if</span>(event.<span class="property">wheelDelta</span> &gt; <span class="number">0</span> || event.<span class="property">detail</span> &lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//向上滚动</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//向下滚动</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">test.<span class="property">addEventListener</span> &amp;&amp; test.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMMouseScroll&quot;</span>, test.<span class="property">onmousewheel</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>​    2.键盘事件</p>
<p>​        只有可以获取焦点的事件或者document绑定键盘事件才可以触发</p>
<p>​        onkeydown</p>
<p>​            当一直按着时，事件会被连续触发，当连续触发的时候，第一次和第二次间隔会稍微长一些后面的才会快速触发，为了防止误操作<br>​            在文本框键入字母属于文本框的默认行为<br>​            事件属性：</p>
<blockquote>
<p>​             event.altKey<br>​             event.ctrlKey<br>​             event.shiftKey</p>
</blockquote>
<p>​             当这三个键被按下时它们的值会被赋值为true否则为false</p>
<p>​    3.mouseenter    鼠标移入</p>
<p>​    4.mouseleave    鼠标移出</p>
<p>​    5.mouseover      鼠标移入</p>
<p>​    6.mouseout      鼠标移出</p>
<p>​    7.contextmenu       上下文菜单事件，可以通过阻止默认行为来自定义上下文菜单</p>
<p>​    8.beforeunload     通常在切换页面时触发</p>
<p>​    9.DOMContextLoad    在DOM树渲染完成后触发，不管CSS，JS文件是否渲染完毕</p>
<p>​    以上四个事件触发机制: 当鼠标移动至绑定监听器的元素或者子元素时就会被触发</p>
<p>​    区别: 前两者不会冒泡后两者会</p>
<h3 id="事件模拟"><a href="#事件模拟" class="headerlink" title="事件模拟"></a>事件模拟</h3><p>​    普通浏览器,还包括IE10及以上</p>
<p>​    API:<br>​    document.createEvent(eventname)</p>
<p>​    传入一个字符串当做参数，这个字符串在DOM2与DOM3标准中有不同的形式，DOM3中将复数变成单数，建议不要再使用DOM2的标准</p>
<ol>
<li><p>UIEvents 一般化的UI事件，鼠标与键盘事件都继承自此事件，在DOM3中是UIEvent</p>
</li>
<li><p>ouseEvents 鼠标事件，在DOM3中是MouseEvent</p>
</li>
<li><p>MutationEvents   一般化的DOM变动事件，在DOM3中是MutationEvent</p>
</li>
<li><p>HTMLEvents    一般化的HTML事件，没有对应的DOM3事件</p>
<p>   在DOM2中没有键盘事件，但是在DOM3中实现了KeyboardEvent，返回值是一个对应的event对象，根据不同的事件子类有不同的初始化方法</p>
<p>   以MouseEvent为例，初始化方法为initMouseEvent，传入参数与事件类型有关，详细内容需要参考mdn文档</p>
<p>   在DOM3中还定义了自定义事件CustomEvent，返回的对象通过initCustomEvent初始化</p>
<p>   element.dispatchEvent(event)</p>
<p>   传入一个事件对象<br>   用来触发事件对象定义的事件</p>
<p>   IE9及以下</p>
<p>   API:</p>
<p>   document.createEventObject()</p>
<p>   没有参数</p>
<p>   返回值是一个event对象，event的所有属性与方法都需要自定义，没有预设参数</p>
<p>   element.fireEvent(eventname, event)</p>
<p>   第一个参数是事件名，如onclick等</p>
<p>   第二个参数是自定义的event，</p>
</li>
</ol>
<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><h3 id="1-Window"><a href="#1-Window" class="headerlink" title="1.Window"></a>1.Window</h3><p> 代表浏览器窗口并且保存浏览器的全局对象</p>
<p>  window.open 当弹窗被浏览器内置工具屏蔽时会返回null，被工具屏蔽会报</p>
<h3 id="2-Navigator"><a href="#2-Navigator" class="headerlink" title="2.Navigator"></a>2.Navigator</h3><p>代表浏览器信息</p>
<p>由于历史原因大部分属性没有意义，只剩下<strong>userAgent</strong>可以判断浏览器类型</p>
<p>&#x2F;chrome&#x2F;i.test(navigator.userAgent)<br>&#x2F;firefox&#x2F;i.test(navigator.userAgent)</p>
<p>IE11的userAgent中没有IE信息必须使用”ActiveXObject” in window来进行判断</p>
<p> edge仍然可以使用userAgent来判断有无edge</p>
<h3 id="3-Location"><a href="#3-Location" class="headerlink" title="3.Location"></a>3.Location</h3><p>代表浏览器地址栏信息</p>
<p>如果直接打印location，则能获取到当前网址栏的信息</p>
<p>修改location属性为一个完整路径或相对路径则页面会直接跳转</p>
<p>–assign()</p>
<p>直接跳转到某个页面，与直接修改location一样</p>
<p> –reload()</p>
<p> 用于重新加载当前页面，与刷新按钮一样，传递true作为参数时会强制清空缓存</p>
<p> –replace()</p>
<p> 与assign类似但是它不会生成历史记录，无法回退</p>
<h3 id="4-History"><a href="#4-History" class="headerlink" title="4.History"></a>4.History</h3><p>代表历史记录，<strong>只能前进后退</strong></p>
<p>–length</p>
<p>当次访问的历史次数，关闭浏览器时清零</p>
<p>–back()</p>
<p> 回到上一个页面</p>
<p>  –forward()</p>
<p> 前往下一个页面</p>
<p> –go()</p>
<p> 使用整数作为参数来指定需要跳转到的页面</p>
<h3 id="5-Screen"><a href="#5-Screen" class="headerlink" title="5.Screen"></a>5.Screen</h3><p>代表用户当前屏幕</p>
<p>这些属性都保存在<strong>window</strong>中，可以直接使用</p>
<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p> window.setInterval(func, num)</p>
<p> 返回值为此定时器的标识</p>
<p> window.clearInterval(定时器标识)</p>
<h4 id="延时调用"><a href="#延时调用" class="headerlink" title="延时调用"></a>延时调用</h4><p>window.setTimeout(func, num)</p>
<p>经过num毫秒后调用，<strong>只调用一次</strong></p>
<h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><p> JSON是一个<strong>特定格式的字符串</strong>，几乎所有语言都能识别</p>
<p>​      能够转换成每个语言的对象，主要用于数据交互</p>
<p>​      javascript object notation</p>
<p>JSON与js对象格式相同但是属性和值<strong>必须加引号</strong></p>
<h3 id="JSON分类："><a href="#JSON分类：" class="headerlink" title="JSON分类："></a>JSON分类：</h3><ul>
<li>对象</li>
<li>数组</li>
</ul>
<h3 id="JSON中可以使用的值："><a href="#JSON中可以使用的值：" class="headerlink" title="JSON中可以使用的值："></a>JSON中可以使用的值：</h3><ul>
<li>数字</li>
<li>字符串</li>
<li>布尔值</li>
<li>null</li>
<li>对象</li>
<li>数组</li>
</ul>
<h3 id="JSON-—-js对象"><a href="#JSON-—-js对象" class="headerlink" title="JSON —&gt; js对象"></a>JSON —&gt; js对象</h3><p>JSON.parse()</p>
<p>使用JSON对象作为参数，返回js对象</p>
<h3 id="js对象-—-JSON"><a href="#js对象-—-JSON" class="headerlink" title="js对象 —&gt; JSON"></a>js对象 —&gt; JSON</h3><p> JSON.stringify()</p>
<p> 使用js对象作为参数，返回JSON</p>
<p>兼容IE7及以下使用eval来代替不能使用的JSON.parse(),或者引入JSON2库</p>
<p>eval()</p>
<p>  如果执行的字符串中有{}，则会被当做代码块，如果不希望被当做代码块被解析，在{}前后使用()<br>   由于效率与安全问题，尽量不要使用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/10/22/JavaScript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="clwdo6pgo0006k4tx7liu8trz" data-title="JavaScript基础学习笔记" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/" rel="tag">前端学习</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/10/23/AJAX%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          AJAX学习笔记
        
      </div>
    </a>
  
  
    <a href="/2023/10/16/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">git学习笔记</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AJAX/">AJAX</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Axios/">Axios</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Css/">Css</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Html/">Html</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/">JS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E5%B7%A7/">技巧</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E8%AE%B0/">杂记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/" rel="tag">专业知识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AA%E4%BA%BA%E5%88%86%E4%BA%AB/" rel="tag">个人分享</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/" rel="tag">前端学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag">基础编程语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Web/" style="font-size: 12px;">Web</a> <a href="/tags/%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/" style="font-size: 10px;">专业知识</a> <a href="/tags/%E4%B8%AA%E4%BA%BA%E5%88%86%E4%BA%AB/" style="font-size: 10px;">个人分享</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/" style="font-size: 20px;">前端学习</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 18px;">基础编程语言</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 14px;">数据结构</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 16px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/11/12/Vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Vue全家桶学习笔记</a>
          </li>
        
          <li>
            <a href="/2023/11/12/ES6-11%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">ES6-11学习笔记</a>
          </li>
        
          <li>
            <a href="/2023/11/05/JavaScript%E9%AB%98%E7%BA%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">JavaScript高级学习笔记</a>
          </li>
        
          <li>
            <a href="/2023/10/30/Axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Axios学习笔记</a>
          </li>
        
          <li>
            <a href="/2023/10/23/AJAX%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">AJAX学习笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>